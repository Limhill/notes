## useReducer

useReducer принимает на вход 2 или 3 аргумента, в зависимости от выбранного способа.

Например, пишем счётчик.

**Способ 1: Задать начальное значение сразу при вызове хука.**

 ```ts
 const [state, dispatch] = useReducer(reducer, { count: 0 })
```

Принцип как в Редаксе. Есть стейты, которые мы сами объявляем и присваиваем им стартовые значения.
Здесь стейт называем count и присваиваем 0.
Можно присвоить initialState или любую другую переменную. Более того, можно эту переменную получить 
как проп в компонент.

**Способ 2: Задать значение "лениво"**

```ts
const [state, dispatch] = useReducer(reducer, someInitValue, initValueSetter)
```

Здесь someInitValue - это просто значение по умолчанию (ну например число 0), а вот initValueSetter - это
функция, которая принимает аргументом someInitValue и возвращает объект. В этом объекте ключ - это стейт, 
а значение - это значение этого стейта по умолчанию.

**ВАЖНО** В этом объекте, в теории может быть сколько угодно ключей и значений, но someInitValue всегда 
ОДНО значение. Правда это может быть объект (нафига ты тогда выбрал второй способ ёпта), массив или 
что-то ещё.

Казалось бы, нафига тогда оно надо? Но тут вся соль в названии второго метода. Это ленивая инициализация.
Начальное значение будет рассчитано функцией initValueSetter всего один единственный раз при первом вызове
хука.

Вот [тут](https://stackoverflow.com/a/62505353/19995759) чел дал просто гениальный развёрнутый ответ 
на вопрос "Зачем вообще нужна ленивая инициализация?" (хотя вопрос был другим, лол).